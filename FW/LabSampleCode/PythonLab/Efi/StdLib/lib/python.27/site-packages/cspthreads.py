#
# Edk2 CSP Threads
#
# Channel based Threads for Python on EDK II.
# Based on Hoare's Communicating Sequential Processes (CSP).
#
# A Channel is a unidirectional pipeline between two threads.
# A BiDi is a bidirectional link between two threads comprised of two Channels.
#
# Each end of a Channel, or BiDi, is tagged with the ID of the thread that owns it.
#
# When a CSP Thread is created, a BiDi is associated with it with the upstream
# end assigned to the thread and the downstream end unassociated.  A dictionary
# of the BiDis is created, indexed by the thread ident, containing the Read and
# Write endpoints for the downstream side.
#                     ________
#   Downstream  w ---|________|--> r  Upstream
#                     ________
#   Downstream  r <--|________|--- w  Upstream
#

import os
from  threading import *
from  channel   import Channel

_BiDiLock   = Lock()

#_assoc = {}

_DontOwnMsgC  = "Can't %s a channel you don't own!"
_DontOwnMsgB  = "Can't %s a BiDi you don't own!"
_AlreadyOwnMsgC  = "Can't %s a channel you already own!"
_AlreadyOwnMsgB  = "Can't %s a BiDi you already own!"


class BiDi:
  def __init__(self):
    self.UpOwner    = None
    self.DownOwner  = None
    self.DU   = Channel()
    self.UD   = Channel()

  def Open(self):
    myID = currentThread().ident

    if (myID == self.UpOwner) or (myID == self.DownOwner):
        raise RuntimeError(_AlreadyOwnMsgB % "open")

    with _BiDiLock:
      if (self.UpOwner == None):
          self.UpOwner = myID
      elif (self.DownOwner == None):
          self.DownOwner = myID
      else:
          raise RuntimeError("Can't open a BiDi owned by someone else!")

  def Close(self):
    myID = currentThread().ident

    if (self.UpOwner == myID):
        self.UpOwner = None
    elif (self.DownOwner == myID):
        self.DownOwner = None
    else:
        raise RuntimeError(_DontOwnMsgB % "close")

  def Read(self, n):
    myID = currentThread().ident

    if (self.UpOwner == myID):
        target = self.DU
    elif (self.DownOwner == myID):
        target = self.UD
    else:
        raise RuntimeError(_DontOwnMsgB % "read")
    return target.Read(n)

  def Write(self, str):
    myID = currentThread().ident

    if (self.UpOwner == myID):
        target = self.UD
    elif (self.DownOwner == myID):
        target = self.DU
    else:
        raise RuntimeError(_DontOwnMsgB % "write")
    return target.Write(str)


class CommThread(Thread):
    def __init__(self, function, Name, arglist=[], kwargs={}):
      self.Comms  = BiDi()
      newargs = [Name, self.Comms] + arglist
      Thread.__init__(self, target=function, args=newargs)

    def Connect(self):
      self.Comms.Open()

    def Disconnect(self):
      self.Comms.Close()

    def Write(self, str):
      return self.Comms.Write(str)

    def Read(self, n=4096):
      return self.Comms.Read(n)

from time import sleep as _sleep

def test():
    class ProducerThread(Thread):

        def __init__(self, chan, limit):
            Thread.__init__(self)
            self.channel  = chan
            self.limit    = limit

        def run(self):
            from random import random
            counter = 0
            while counter < self.limit:
                counter = counter + 1
                self.channel.write("%s.%d" % (self.name, counter))
                _sleep(random() * 0.00001)


    class ConsumerThread(Thread):

        def __init__(self, chan, count):
            Thread.__init__(self)
            self.channel  = chan
            self.count    = count

        def run(self):
            while self.count > 0:
                item = self.channel.read()
                print item
                self.count = self.count - 1

    p2c = Channel()
    Lim = 10

    P = ProducerThread(p2c, Lim)

    C = ConsumerThread(p2c, Lim)

    P.start()
    _sleep(0.000001)

    C.start()
    P.join()
    C.join()
